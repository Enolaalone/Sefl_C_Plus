## **最短路径算法-迪杰斯特拉(Dijkstra)算法**

迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。
它的主要特点是以起始点为中心向外层层扩展(广度优先遍历思想)，直到扩展到终点为止。


**基本思想**

1. 通过Dijkstra计算图G中的最短路径时，需要指定一个起点D(即从顶点D开始计算)。
2. 此外，引进两个数组S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点D的距离)。
3. 初始时，数组S中只有起点D；数组U中是除起点D之外的顶点，并且数组U中记录各顶点到起点D的距离。如果顶点与起点D不相邻，距离为无穷大。
4. 然后，从数组U中找出路径最短的顶点K，并将其加入到数组S中；同时，从数组U中移除顶点K。接着，更新数组U中的各顶点到起点D的距离。
5. 重复第4步操作，直到遍历完所有顶点。

### **迪杰斯特拉(Dijkstra)算法图解**



![img](https://pic1.zhimg.com/80/v2-cdd360483874245e65eb96c8374b598c_1440w.webp)



以上图为例，来对迪杰斯特拉进行算法演示(以顶点D为起点)。

![img](https://pic4.zhimg.com/80/v2-d29190c3a51249cbbc0be5ed8ebb7c13_1440w.webp)



**初始状态**：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！
**第1步**：将顶点D加入到S中。
此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。 注:C(3)表示C到起点D的距离是3。

**第2步**：将顶点C加入到S中。
上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。
此时，S={D(0),C(3)}, U={A(∞),B(13),E(4),F(9),G(∞)}。

**第3步**：将顶点E加入到S中。
上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。
此时，S={D(0),C(3),E(4)}, U={A(∞),B(13),F(6),G(12)}。

**第4步**：将顶点F加入到S中。
此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。

**第5步**：将顶点G加入到S中。
此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。

**第6步**：将顶点B加入到S中。
此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。

**第7步**：将顶点A加入到S中。
此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。

此时，起点D到各个顶点的最短距离就计算出来了：**A(22) B(13) C(3) D(0) E(4) F(6) G(1**

### 程序实现：

```c
void dijkstra(AL p[],int pre[],int dtc[],int source,int i){
    bool visited[i];//是否访问
    for (int j = 0; j < i; ++j) {//初始化
        visited[j]=false;
        pre[j]=-1;
        dtc[j]=INT_MAX;//无穷大
    }
    dtc[source]=0;//A到本身距离为0
    int n;//到原点距离最小数组序号
    for (int j = 0; j < i-1; ++j) {//遍历i-1次
        int min=INT_MAX;
        for (int k = 0; k < i; ++k) {//遍历dtc找到路径最短
            if(!visited[k]&&dtc[k]<min){
                min=dtc[k];
                n=k;
            }
        }
        visited[n]=true;//节点找到

        // 更新当前最短路径和前驱顶点
        // 即，更新"未获取最短路径的顶点的最短路径和前驱顶点"。

        L ql=p[n].next;//相邻节点链接
        while(ql){
            if(!visited[ql->num]&&p[n].weight+dtc[n]<dtc[ql->num]&&dtc[n]!=INT_MAX){
                dtc[ql->num]=p[n].weight+dtc[n];//更新相邻节点路长
                pre[ql->num]=n;//ql->num的前驱节点为n
            }
            ql=ql->next;
        }
    }
}

```

